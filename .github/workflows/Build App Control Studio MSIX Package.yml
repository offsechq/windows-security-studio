name: Build App Control Studio MSIX Package

on:
  workflow_dispatch: # Only the repository's owner can initiate this workflow

# Prevent the workflow from running more than once per change
concurrency:
  group: ACMBuildWorkFlowGitHubSource
  cancel-in-progress: true

jobs:
  build:
    runs-on: windows-2025

    # Create outputs for this job where only other job that use "needs" keyword can use them. This job itself cannot access them.
    outputs:
      DRAFT_RELEASE_ID: ${{ steps.find_draft_release.outputs.DRAFT_RELEASE_ID }}
      DRAFT_RELEASE_TAG: ${{ steps.find_draft_release.outputs.DRAFT_RELEASE_TAG }}
      PACKAGE_VERSION: ${{ steps.main_buildOp.outputs.PACKAGE_VERSION }}
      MSIXBundle_PATH: ${{ steps.main_buildOp.outputs.MSIXBundle_PATH }}
      MSIXBundle_NAME: ${{ steps.main_buildOp.outputs.MSIXBundle_NAME }}
      X64MSBuildLog_PATH: ${{ steps.main_buildOp.outputs.X64MSBuildLog_PATH }}
      X64Symbol_PATH: ${{ steps.main_buildOp.outputs.X64Symbol_PATH }}
      X64Symbol_NAME: ${{ steps.main_buildOp.outputs.X64Symbol_NAME }}
      SBOM_PATH: ${{ steps.main_buildOp.outputs.SBOM_PATH }}
      SBOM_NAME: ${{ steps.main_buildOp.outputs.SBOM_NAME }}
      CERT_PATH: ${{ steps.main_buildOp.outputs.CERT_PATH }}
      CERT_NAME: ${{ steps.main_buildOp.outputs.CERT_NAME }}

    permissions:
      contents: write # Required for adding files to the GitHub draft release

    steps:
      #      - name: Updating Winget
      #        shell: pwsh
      #        run: |
      #          try {
      #              Write-Host -Object 'The version of the pre-installed Winget on the Runner:'
      #              Write-Host -Object (winget --version)
      #          }
      #          catch {
      #              Write-Host -Object 'Winget is not installed.'
      #          }
      #
      #          # Retrieve the latest Winget release information
      #          $WingetReleases = Invoke-RestMethod -Uri 'https://api.github.com/repos/microsoft/winget-cli/releases'
      #          $LatestRelease = $WingetReleases | Select-Object -First 1
      #          # Direct links to the latest Winget release assets
      #          [string]$WingetURL = $LatestRelease.assets.browser_download_url | Where-Object -FilterScript { $_.EndsWith('.msixbundle') } | Select-Object -First 1
      #          [string]$WingetLicense = $LatestRelease.assets.browser_download_url | Where-Object -FilterScript { $_.EndsWith('License1.xml') } | Select-Object -First 1
      #          [string]$LatestWingetReleaseDependenciesZipURL = $LatestRelease.assets.browser_download_url | Where-Object -FilterScript { $_.EndsWith('DesktopAppInstaller_Dependencies.zip') } | Select-Object -First 1
      #          [hashtable]$Downloads = @{
      #              # 'Winget.msixbundle'                 = 'https://aka.ms/getwinget' This is updated slower than the GitHub release
      #              'DesktopAppInstaller_Dependencies.zip' = $LatestWingetReleaseDependenciesZipURL
      #              'Winget.msixbundle'                    = $WingetURL
      #              'License1.xml'                         = $WingetLicense
      #          }
      #          $Downloads.GetEnumerator() | ForEach-Object -Parallel {
      #              Invoke-RestMethod -Uri $_.Value -OutFile $_.Key
      #          }
      #
      #          Expand-Archive -Path 'DesktopAppInstaller_Dependencies.zip' -DestinationPath .\ -Force
      #          # Get the paths to all of the dependencies
      #          [string[]]$DependencyPaths = (Get-ChildItem -Path .\x64 -Filter '*.appx' -File -Force).FullName
      #
      #          # Required to update the Winget
      #          Stop-Process -Name 'WindowsTerminal' -Force -ErrorAction Ignore
      #
      #          Add-AppxProvisionedPackage -Online -PackagePath 'Winget.msixbundle' -DependencyPackagePath $DependencyPaths -LicensePath 'License1.xml'
      #
      #          Add-AppPackage -Path 'Winget.msixbundle' -DependencyPath "$($DependencyPaths[0])", "$($DependencyPaths[1])" -ForceTargetApplicationShutdown -ForceUpdateFromAnyVersion
      #

      - name: Check out the repository code
        uses: actions/checkout@v6

      - name: Cache NuGet packages
        uses: actions/cache@v5
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj', '**/global.json') }}
          restore-keys: nuget-${{ runner.os }}-

      - name: Cache Cargo dependencies
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ./App Control Studio/eXclude/Rust Interop Library/target
          key: cargo-${{ runner.os }}-${{ hashFiles('**/Cargo.lock', '**/Cargo.toml') }}
          restore-keys: cargo-${{ runner.os }}-

      - name: Cache SBOM Tool
        uses: actions/cache@v5
        id: sbom-cache
        with:
          path: ${{ runner.temp }}/sbom-tool.exe
          key: sbom-tool-win-x64-v1

      - name: Building And Packaging the App Control Studio
        id: main_buildOp
        shell: pwsh
        env:
          PARTNERCENTER_APPLICATIONID: ${{ secrets.PARTNERCENTER_APPLICATIONID }}
          PARTNERCENTER_CLIENTID: ${{ secrets.PARTNERCENTER_CLIENTID }}
          PARTNERCENTER_CLIENTSECRET: ${{ secrets.PARTNERCENTER_CLIENTSECRET }}
          PARTNERCENTER_TOKENENDPOINT: ${{ secrets.PARTNERCENTER_TOKENENDPOINT }}
          OFFSECHQ_SIGNING_PFX_BASE64: ${{ secrets.OFFSECHQ_SIGNING_PFX_BASE64 }}
          OFFSECHQ_SIGNING_PFX_PASSWORD: ${{ secrets.OFFSECHQ_SIGNING_PFX_PASSWORD }}
        working-directory: "./App Control Studio" # Setting up working directory to ensure dotnet build will see the global.json file in the "App Control Studio" sub-directory
        run: |
          # Requires -Version 5.1
          # Requires -RunAsAdministrator
          function Build_ACM {
              param(
                  [bool]$DownloadRepo,
                  [bool]$InstallDeps,
                  [bool]$Workflow,
                  [bool]$UpdateWorkLoads,
                  [bool]$Install,
                  [bool]$Upload
              )

              [string]$PackageFamilyName = 'OFFSECHQ.AppControlStudio_52ydnp6c4w3g1'
              [string]$PackageHashAlgo = 'SHA256'
              [string]$PackagePublisher = 'CN=520167C9-C63F-4572-841C-0538368FD2C2'
              [string]$PackageName = 'OFFSECHQ.AppControlStudio'
              [string]$PackagePhoneProductId = '199a23ec-7cb6-4ab5-ab50-8baca348bc79'
              [string]$PackagePhonePublisherId = '00000000-0000-0000-0000-000000000000'
              [string]$PackagePublisherDisplayName = 'OFFSECHQ'


              $ErrorActionPreference = 'Stop'
              # Start the stopwatch
              $Stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

              # --- Version Sync Logic ---
              Write-Host "Syncing Package.appxmanifest version with .csproj..." -ForegroundColor Cyan
              $csprojPath = "App Control Studio.csproj"
              $manifestPath = "Package.appxmanifest"

              if (Test-Path $csprojPath) {
                  $csprojContent = Get-Content $csprojPath -Raw
                  if ($csprojContent -match '<Version>(.*?)</Version>') {
                      $appVersion = $matches[1]
                      Write-Host "Found version in csproj: $appVersion"
                      
                      if (Test-Path $manifestPath) {
                          $manifestContent = Get-Content $manifestPath -Raw
                          # Update the Version attribute in the Identity tag
                          $newManifestContent = $manifestContent -replace 'Version="\d+\.\d+\.\d+\.\d+"', "Version=""$appVersion"""
                          Set-Content $manifestPath -Value $newManifestContent -Encoding UTF8
                          Write-Host "Success: Updated Package.appxmanifest to version $appVersion" -ForegroundColor Green
                      } else {
                          Write-Warning "Package.appxmanifest not found at $manifestPath"
                      }
                  } else {
                      Write-Warning "Could not extract Version from .csproj"
                  }
              } else {
                  Write-Warning ".csproj file not found at $csprojPath"
              }
              # --------------------------

              Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem' -Name 'LongPathsEnabled' -Value 1 -Force

              [System.String]$script:AppControlManagerDirectory

              if ($DownloadRepo) {

                  [System.String]$BranchName = 'main'
                  [System.String]$RepoName = 'windows-security-studio'
                  [System.String]$RepoUrl = "https://github.com/OFFSECHQ/$RepoName/archive/refs/heads/$BranchName.zip"
                  [System.String]$ZipPath = [System.IO.Path]::Combine($env:TEMP, "$RepoName.zip")
                  [System.String]$InitialWorkingDirectory = $PWD.Path
                  $script:AppControlManagerDirectory = [System.IO.Path]::Combine($InitialWorkingDirectory, "$RepoName-$BranchName", 'App Control Studio')

                  if (Test-Path -Path $script:AppControlManagerDirectory -PathType Container) {
                      Remove-Item -Path $script:AppControlManagerDirectory -Recurse -Force
                  }

                  Invoke-WebRequest -Uri $RepoUrl -OutFile $ZipPath
                  Expand-Archive -Path $ZipPath -DestinationPath $InitialWorkingDirectory -Force
                  Remove-Item -Path $ZipPath -Force
                  Set-Location -Path $script:AppControlManagerDirectory
              }
              else {
                  $script:AppControlManagerDirectory = $PWD.Path
              }

              if ($InstallDeps) {

                  # Install Winget if it doesn't exist
                  if (!(Get-Command -Name 'winget.exe' -ErrorAction Ignore)) {

                      # Retrieve the latest Winget release information
                      $WingetReleases = Invoke-RestMethod -Uri 'https://api.github.com/repos/microsoft/winget-cli/releases'
                      $LatestRelease = $WingetReleases | Select-Object -First 1
                      # Direct links to the latest Winget release assets
                      [string]$WingetURL = $LatestRelease.assets.browser_download_url | Where-Object -FilterScript { $_.EndsWith('.msixbundle') } | Select-Object -First 1
                      [string]$WingetLicense = $LatestRelease.assets.browser_download_url | Where-Object -FilterScript { $_.EndsWith('License1.xml') } | Select-Object -First 1
                      [string]$LatestWingetReleaseDependenciesZipURL = $LatestRelease.assets.browser_download_url | Where-Object -FilterScript { $_.EndsWith('DesktopAppInstaller_Dependencies.zip') } | Select-Object -First 1
                      [hashtable]$Downloads = @{
                          # 'Winget.msixbundle'                 = 'https://aka.ms/getwinget' This is updated slower than the GitHub release
                          'DesktopAppInstaller_Dependencies.zip' = $LatestWingetReleaseDependenciesZipURL
                          'Winget.msixbundle'                    = $WingetURL
                          'License1.xml'                         = $WingetLicense
                      }
                      $Downloads.GetEnumerator() | ForEach-Object -Parallel {
                          Invoke-RestMethod -Uri $_.Value -OutFile $_.Key
                      }

                      Expand-Archive -Path 'DesktopAppInstaller_Dependencies.zip' -DestinationPath .\ -Force

                      # Required to update the Winget
                      Stop-Process -Name 'WindowsTerminal' -Force -ErrorAction Ignore

                      # Get the paths to all of the dependencies
                      [string[]]$DependencyPaths = (Get-ChildItem -Path .\x64 -Filter '*.appx' -File -Force).FullName
                      Add-AppxProvisionedPackage -Online -PackagePath 'Winget.msixbundle' -DependencyPackagePath $DependencyPaths -LicensePath 'License1.xml'

                      Add-AppPackage -Path 'Winget.msixbundle' -DependencyPath "$($DependencyPaths[0])", "$($DependencyPaths[1])" -ForceTargetApplicationShutdown -ForceUpdateFromAnyVersion

                  }

                  Write-Host -Object 'The version of the Winget currently in use:'
                  Write-Host -Object (winget --version)

                  winget source update

                  # Smart install - only install if not already present
                  Write-Host -Object "`nChecking Rust toolchain..." -ForegroundColor Magenta
                  if (Get-Command rustc -ErrorAction SilentlyContinue) {
                      Write-Host -Object "Rust already installed: $(rustc --version)" -ForegroundColor Green
                  } else {
                      Write-Host -Object "Installing Rust toolchain..." -ForegroundColor Yellow
                      $null = winget install --id Rustlang.Rustup --exact --accept-package-agreements --accept-source-agreements --force --source winget
                      if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed to install the Rust toolchain: $LASTEXITCODE") }
                  }

                  Write-Host -Object "`nChecking .NET SDK..." -ForegroundColor Magenta
                  $dotnetVersion = dotnet --version 2>$null
                  if ($dotnetVersion -and $dotnetVersion -match '^10\.') {
                      Write-Host -Object "NET SDK 10 already installed: $dotnetVersion" -ForegroundColor Green
                  } else {
                      Write-Host -Object "Installing .NET SDK 10..." -ForegroundColor Yellow
                      $null = winget install --id Microsoft.DotNet.SDK.10 --exact --accept-package-agreements --accept-source-agreements --force --source winget
                      if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed to install .NET SDK: $LASTEXITCODE") }
                  }

                  Write-Host -Object "`nChecking Visual Studio Build Tools..." -ForegroundColor Magenta
                  # Check if VS Build Tools or VS is installed via vswhere
                  $vsInstall = & 'C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe' -prerelease -latest -property installationPath 2>$null
                  if ($vsInstall -and (Test-Path "$vsInstall\Common7\Tools\vsdevcmd.bat")) {
                      Write-Host -Object "Visual Studio/Build Tools already installed at: $vsInstall" -ForegroundColor Green
                  } else {
                      Write-Host -Object "Installing Visual Studio Build Tools..." -ForegroundColor Yellow
                      # Using this until version 18 build tools are added to Winget
                      Invoke-RestMethod -Uri "https://aka.ms/vs/18/insiders/vs_BuildTools.exe" -OutFile "vs_BuildTools.exe"
                      Start-Process -Wait -FilePath .\vs_BuildTools.exe -ArgumentList '--force --wait --passive --add Microsoft.VisualStudio.Workload.VCTools --add Microsoft.VisualStudio.Workload.MSBuildTools --add Microsoft.VisualStudio.Workload.UniversalBuildTools --add Microsoft.VisualStudio.Component.VC.Tools.x86.x64 --add Microsoft.VisualStudio.Component.Windows11SDK.26100 --includeRecommended'
                      if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New('Failed to install Visual Studio Build Tools') }
                  }

                  # winget install --id Microsoft.VCRedist.2015+.x64 --exact --accept-package-agreements --accept-source-agreements --uninstall-previous --force --source winget

              }

              # Refresh the environment variables so the current session detects the new dotnet installation
              $Env:Path = [System.Environment]::GetEnvironmentVariable('Path', [System.EnvironmentVariableTarget]::Machine) + ';' +
              [System.Environment]::GetEnvironmentVariable('Path', [System.EnvironmentVariableTarget]::User)

              # https://github.com/Microsoft/vswhere/wiki/Start-Developer-Command-Prompt#using-powershell
              $installationPath = . 'C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe' -prerelease -latest -property installationPath
              if ($installationPath -and (Test-Path -Path "$installationPath\Common7\Tools\vsdevcmd.bat" -PathType Leaf)) {
                  & "${env:COMSPEC}" /s /c "`"$installationPath\Common7\Tools\vsdevcmd.bat`" -no_logo && set" | ForEach-Object -Process {
                      $name, $value = $_ -split '=', 2
                      Set-Content -Path env:\"$name" -Value $value -Force
                      Write-Host -Object "Setting environment variable: $name=$value"
                  }
              }

              # Remove any possible existing directories
              Remove-Item -Path .\MSIXOutputX64 -Recurse -Force -ErrorAction Ignore
              Remove-Item -Path .\MSIXBundleOutput -Recurse -Force -ErrorAction Ignore
              Remove-Item -Path .\bin -Recurse -Force -ErrorAction Ignore
              Remove-Item -Path .\obj -Recurse -Force -ErrorAction Ignore

              if ($UpdateWorkLoads) {
                  # Update the workloads
                  dotnet workload update
                  dotnet workload config --update-mode workload-set
                  dotnet workload update
                  if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed updating the workloads. Exit Code: $LASTEXITCODE") }
              }

              Write-Host -Object "`nChecking .NET info`n`n" -ForegroundColor Magenta
              dotnet --info
              Write-Host -Object "`nListing installed .NET SDKs`n`n" -ForegroundColor Magenta
              dotnet --list-sdks

              function Find-mspdbcmf {
                  # "-products *" is necessary to detect BuildTools too
                  [string]$VisualStudioPath = . 'C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe' -prerelease -latest -property resolvedInstallationPath -products *

                  [string]$BasePath = [System.IO.Path]::Combine($VisualStudioPath, 'VC', 'Tools', 'MSVC')

                  # Get all subdirectories under the base path
                  [System.String[]]$VersionDirs = [System.IO.Directory]::GetDirectories($BasePath)

                  # Initialize the highest version with a minimal version value.
                  [System.Version]$HighestVersion = [System.Version]::New('0.0.0.0')
                  [System.String]$HighestVersionFolder = $null

                  # Loop through each directory to find the highest version folder.
                  foreach ($Dir in $VersionDirs) {
                      # Extract the folder name
                      [System.String]$FolderName = [System.IO.Path]::GetFileName($Dir)
                      [System.Version]$CurrentVersion = $null
                      # Try parsing the folder name as a Version.
                      if ([System.Version]::TryParse($FolderName, [ref] $CurrentVersion)) {
                          # Compare versions
                          if ($CurrentVersion.CompareTo($HighestVersion) -gt 0) {
                              $HighestVersion = $CurrentVersion
                              $HighestVersionFolder = $FolderName
                          }
                      }
                  }

                  # If no valid version folder is found
                  if (!$HighestVersionFolder) {
                      throw [System.IO.DirectoryNotFoundException]::New("No valid version directories found in $BasePath")
                  }

                  # Combine the base path, the highest version folder, the architecture folder, and the file name.
                  [System.String]$mspdbcmfPath = [System.IO.Path]::Combine($BasePath, $HighestVersionFolder, 'bin', 'Hostx64', 'x64', 'mspdbcmf.exe')

                  if (![System.IO.File]::Exists($mspdbcmfPath)) {
                      throw [System.IO.FileNotFoundException]::New("mspdbcmf.exe not found at $mspdbcmfPath")
                  }

                  return $mspdbcmfPath
              }

              [string]$mspdbcmfPath = Find-mspdbcmf

              function Find-MSBuild {
                  # "-products *" is necessary to detect BuildTools too
                  [string]$VisualStudioPath = . 'C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe' -prerelease -latest -property resolvedInstallationPath -products *

                  [string]$MSBuildPath = [System.IO.Path]::Combine($VisualStudioPath, 'MSBuild', 'Current', 'Bin', 'MSBuild.exe')

                  if (![System.IO.File]::Exists($MSBuildPath)) {
                      throw [System.IO.FileNotFoundException]::New("MSBuild.exe not found at $MSBuildPath")
                  }

                  return $MSBuildPath
              }

              [string]$MSBuildPath = Find-MSBuild

              #region --- Compile C++ projects ---

              ### ComManager

              . $MSBuildPath 'eXclude\ComManager\ComManager.slnx' /p:Configuration=Release /p:Platform=x64 /target:"clean;Rebuild"

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed building ComManager solution for X64. Exit Code: $LASTEXITCODE") }

              ### Shell

              [string]$newPFN = "$PackageFamilyName!App"
              [string]$content = Get-Content 'eXclude\Shell\Shell.cpp' -Raw
              [string]$content = $content -replace 'static constexpr LPCWSTR APP_CONTROL_MANAGER_PFN = L"[^"]*";', "static constexpr LPCWSTR APP_CONTROL_MANAGER_PFN = L`"$newPFN`";"
              $content | Set-Content 'eXclude\Shell\Shell.cpp' -NoNewline -Force

              . $MSBuildPath 'eXclude\Shell\Shell.slnx' /p:Configuration=Release /p:Platform=x64 /target:"clean;Rebuild"

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed building the Shell solution for X64. Exit Code: $LASTEXITCODE") }

              #endregion


              #region --- RUST projects ---

              # Uncomment this once stable toolchain supports ehcont security feature, till then we use nightly only
              # rustup default stable
              rustup default nightly

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed setting Rust toolchain to Stable. Exit Code: $LASTEXITCODE") }

              rustup target add x86_64-pc-windows-msvc

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed adding x86_64-pc-windows-msvc target to Rust toolchain. Exit Code: $LASTEXITCODE") }

              rustup update

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed updating Rust. Exit Code: $LASTEXITCODE") }

              cargo version

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed checking for Rust version. Exit Code: $LASTEXITCODE") }

              [string]$Current_Location = (Get-Location).Path

              Set-Location -Path '.\eXclude\Rust Interop Library'

              if (Test-Path -PathType Leaf -LiteralPath 'Cargo.lock') {
                  Remove-Item -Force -LiteralPath 'Cargo.lock'
              }

              rustup toolchain install nightly

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed installing nightly Rust toolchain. Exit Code: $LASTEXITCODE") }

              rustup default nightly

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed setting Rust toolchain to Nightly. Exit Code: $LASTEXITCODE") }

              rustup component add rust-src --toolchain nightly-x86_64-pc-windows-msvc

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed adding rust-src component to Nightly toolchain. Exit Code: $LASTEXITCODE") }

              rustup update

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed updating Rust. Exit Code: $LASTEXITCODE") }

              cargo version

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed checking for Rust version. Exit Code: $LASTEXITCODE") }

              cargo clean

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed cleaning the Rust project. Exit Code: $LASTEXITCODE") }

              cargo update --verbose

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed updating Rust. Exit Code: $LASTEXITCODE") }

              cargo tree

              rustup show active-toolchain

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed showing active Rust toolchain. Exit Code: $LASTEXITCODE") }

              cargo build_x64

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed building x64 Rust Interop project. Exit Code: $LASTEXITCODE") }

              Set-Location -Path $Current_Location

              #endregion

              #region XML Modifications

              [string]$CsProjFilePath = (Resolve-Path -Path '.\App Control Studio.csproj').Path
              [string]$AppxManifestFilePath = (Resolve-Path -Path '.\Package.appxmanifest').Path

              # Adjust the Digest Algorithm based on the package source
              [xml]$ProjXMLContent = Get-Content -Path $CsProjFilePath -Force

              # Grab ALL existing nodes, wherever they are
              $nodes = $ProjXMLContent.SelectNodes('//AppxPackageSigningTimestampDigestAlgorithm')

              foreach ($node in $nodes) {
                  $node.InnerText = $PackageHashAlgo
              }

              $ProjXMLContent.Save($CsProjFilePath)

              # Configure the Package Manifest Dits
              [xml]$AppxManifestContent = Get-Content -Path $AppxManifestFilePath -Force

              $ns = New-Object System.Xml.XmlNamespaceManager($AppxManifestContent.NameTable)
              $ns.AddNamespace('ns', 'http://schemas.microsoft.com/appx/manifest/foundation/windows10')
              $ns.AddNamespace('mp', 'http://schemas.microsoft.com/appx/2014/phone/manifest')

              # Update the <Identity> attributes
              $identity = $AppxManifestContent.SelectSingleNode('/ns:Package/ns:Identity', $ns)
              $identity.SetAttribute('Name', $PackageName)
              $identity.SetAttribute('Publisher', $PackagePublisher)

              # Update the <mp:PhoneIdentity> attributes
              $phoneId = $AppxManifestContent.SelectSingleNode('/ns:Package/mp:PhoneIdentity', $ns)
              $phoneId.SetAttribute('PhoneProductId', $PackagePhoneProductId)
              $phoneId.SetAttribute('PhonePublisherId', $PackagePhonePublisherId)

              # Update the <PublisherDisplayName> element
              $pubDisplay = $AppxManifestContent.SelectSingleNode('/ns:Package/ns:Properties/ns:PublisherDisplayName', $ns)
              $pubDisplay.InnerText = $PackagePublisherDisplayName

              $AppxManifestContent.Save($AppxManifestFilePath)

              #endregion XML Modifications

              # https://learn.microsoft.com/dotnet/core/tools/dotnet-build
              # https://learn.microsoft.com/visualstudio/msbuild/msbuild-command-line-reference
              # https://learn.microsoft.com/visualstudio/msbuild/common-msbuild-project-properties

              # Copy the X64 components to the directory before the build starts
              Copy-Item -Path '.\eXclude\Shell\x64\Release\Shell.dll' -Destination 'Shell' -Force

              Copy-Item -Path '.\eXclude\ComManager\x64\Release\ComManager.exe' -Destination '.\CppInterop\ComManager.exe' -Force

              # Generate for X64 architecture
              dotnet clean 'App Control Studio.csproj' --configuration Release
              dotnet build 'App Control Studio.csproj' --configuration Release --verbosity minimal /p:Platform=x64 /p:RuntimeIdentifier=win-x64

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed building x64 App Control Studio project. Exit Code: $LASTEXITCODE") }

              dotnet msbuild 'App Control Studio.csproj' /t:Publish /p:Configuration=Release /p:RuntimeIdentifier=win-x64 /p:AppxPackageDir="MSIXOutputX64\" /p:GenerateAppxPackageOnBuild=true /p:Platform=x64 -v:minimal /p:MsPdbCmfExeFullpath=$mspdbcmfPath -bl:X64MSBuildLog.binlog

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("Failed packaging x64 App Control Studio project. Exit Code: $LASTEXITCODE") }

              function Get-MSIXFile {
                  param(
                      [System.String]$BasePath,
                      [System.String]$FolderPattern,
                      [System.String]$FileNamePattern,
                      [System.String]$ErrorMessageFolder,
                      [System.String]$ErrorMessageFile
                  )
                  # Get all subdirectories in the base path matching the folder pattern
                  [System.String[]]$Folders = [System.IO.Directory]::GetDirectories($BasePath)
                  [System.String]$DetectedFolder = $null
                  foreach ($Folder in $Folders) {
                      if ([System.Text.RegularExpressions.Regex]::IsMatch($Folder, $FolderPattern)) {
                          $DetectedFolder = $Folder
                          break
                      }
                  }

                  if (!$DetectedFolder) {
                      throw [System.InvalidOperationException]::New($ErrorMessageFolder)
                  }

                  # Get the full path of the first file matching the file name pattern inside the found folder
                  [System.String[]]$Files = [System.IO.Directory]::GetFiles($DetectedFolder)
                  [System.String]$DetectedFile = $null
                  foreach ($File in $Files) {
                      if ([System.Text.RegularExpressions.Regex]::IsMatch($File, $FileNamePattern)) {
                          $DetectedFile = $File
                          break
                      }
                  }

                  if (!$DetectedFile) {
                      throw [System.InvalidOperationException]::New($ErrorMessageFile)
                  }
                  return $DetectedFile
              }


              #region Certificate Creation and Signing

              # Use a persistent self-signed certificate from GitHub Secrets.
              # Fail fast when secrets are missing to avoid accidental fallback cert rotation.
              $CertSubject = $PackagePublisher
              [string]$EncodedPfx = $env:OFFSECHQ_SIGNING_PFX_BASE64
              [string]$PfxPassword = $env:OFFSECHQ_SIGNING_PFX_PASSWORD
              [string]$PfxPath = $null

              if ([string]::IsNullOrWhiteSpace($EncodedPfx) -or [string]::IsNullOrWhiteSpace($PfxPassword)) {
                  throw [System.InvalidOperationException]::New('Required signing secrets OFFSECHQ_SIGNING_PFX_BASE64/OFFSECHQ_SIGNING_PFX_PASSWORD are missing.')
              }

              Write-Host -Object 'Using persistent signing certificate from GitHub Secrets.' -ForegroundColor Cyan

              [byte[]]$PfxBytes = [System.Convert]::FromBase64String($EncodedPfx.Trim())
              [System.Security.SecureString]$SecurePfxPassword = ConvertTo-SecureString -String $PfxPassword -AsPlainText -Force
              $Cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new($PfxBytes, $SecurePfxPassword, [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable)

              if (-not [string]::Equals($Cert.Subject, $CertSubject, [System.StringComparison]::OrdinalIgnoreCase)) {
                  throw [System.InvalidOperationException]::New("Signing certificate subject '$($Cert.Subject)' does not match package publisher '$CertSubject'.")
              }

              $PfxPath = [System.IO.Path]::Combine($env:RUNNER_TEMP, 'OFFSECHQ_CodeSigning.pfx')
              [System.IO.File]::WriteAllBytes($PfxPath, $PfxBytes)

              [System.String[]]$SignCredentialArgs = @('/f', $PfxPath, '/p', $PfxPassword)

              Write-Host -Object "Using certificate thumbprint: $($Cert.Thumbprint)" -ForegroundColor Green

              # Find SignTool.exe (reuses same logic as MakeAppx)
              function Get-SignToolPath {
                  [System.String]$BasePath = 'C:\Program Files (x86)\Windows Kits\10\bin'
                  [System.String[]]$VersionDirs = [System.IO.Directory]::GetDirectories($BasePath)
                  [System.Version]$HighestVersion = [System.Version]::New('0.0.0.0')
                  [System.String]$HighestVersionFolder = $null

                  foreach ($Dir in $VersionDirs) {
                      [System.String]$FolderName = [System.IO.Path]::GetFileName($Dir)
                      [System.Version]$CurrentVersion = $null
                      if ([System.Version]::TryParse($FolderName, [ref] $CurrentVersion)) {
                          if ($CurrentVersion.CompareTo($HighestVersion) -gt 0) {
                              $HighestVersion = $CurrentVersion
                              $HighestVersionFolder = $FolderName
                          }
                      }
                  }

                  if (!$HighestVersionFolder) {
                      throw [System.IO.DirectoryNotFoundException]::New("No valid version directories found in $BasePath")
                  }

                  [string]$CPUArch = @{AMD64 = 'x64'; ARM64 = 'arm64' }[$Env:PROCESSOR_ARCHITECTURE]
                  [System.String]$SignToolPath = [System.IO.Path]::Combine($BasePath, $HighestVersionFolder, $CPUArch, 'signtool.exe')

                  return $SignToolPath
              }

              [System.String]$SignToolPath = Get-SignToolPath

              if ([System.String]::IsNullOrWhiteSpace($SignToolPath) -or -not (Test-Path $SignToolPath)) {
                  throw [System.IO.FileNotFoundException]::New('Could not find signtool.exe')
              }

              Write-Host -Object "Using SignTool at: $SignToolPath" -ForegroundColor Green

              #endregion

              #region Finding X64 outputs
              [System.String]$FinalMSIXX64Path = Get-MSIXFile -BasePath ([System.IO.Path]::Combine($PWD.Path, 'MSIXOutputX64')) -FolderPattern 'App Control Studio_\d+\.\d+\.\d+\.\d+_x64_Test' -FileNamePattern 'App Control Studio_\d+\.\d+\.\d+\.\d+_x64\.msix' -ErrorMessageFolder 'Could not find the directory for X64 MSIX file' -ErrorMessageFile 'Could not find the X64 MSIX file'
              [System.String]$FinalMSIXX64Name = [System.IO.Path]::GetFileName($FinalMSIXX64Path)
              [System.String]$FinalMSIXX64SymbolPath = Get-MSIXFile -BasePath ([System.IO.Path]::Combine($PWD.Path, 'MSIXOutputX64')) -FolderPattern 'App Control Studio_\d+\.\d+\.\d+\.\d+_x64_Test' -FileNamePattern 'App Control Studio_\d+\.\d+\.\d+\.\d+_x64\.appxsym' -ErrorMessageFolder 'Could not find the directory for X64 symbol file' -ErrorMessageFile 'Could not find the X64 symbol file'
              [System.String]$FinalMSIXX64SymbolName = [System.IO.Path]::GetFileName($FinalMSIXX64SymbolPath)

              # Sign X64 MSIX
              Write-Host -Object "Signing X64 MSIX: $FinalMSIXX64Path" -ForegroundColor Magenta
              & $SignToolPath sign /fd $PackageHashAlgo @SignCredentialArgs /td $PackageHashAlgo /tr "http://timestamp.digicert.com" $FinalMSIXX64Path
              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("SignTool failed signing the X64 MSIX. Exit Code: $LASTEXITCODE") }
              #endregion

              #region Detect and Validate File Versions
              [System.Text.RegularExpressions.Regex]$versionRegexX64 = [System.Text.RegularExpressions.Regex]::New('App Control Studio_(\d+\.\d+\.\d+\.\d+)_x64\.msix')

              [System.Text.RegularExpressions.Match]$MatchX64 = $versionRegexX64.Match($FinalMSIXX64Name)

              if (!$MatchX64.Success) {
                  throw [System.InvalidOperationException]::New('Could not detect version from X64 file name')
              }

              [System.String]$versionX64 = $MatchX64.Groups[1].Value

              # Craft the file name for the MSIX Bundle file
              [System.String]$FinalBundleFileName = "App Control Studio_$versionX64.msixbundle"
              #endregion

              # Creating the directory where the MSIX packages will be copied to
              [System.String]$MSIXBundleOutput = [System.IO.Directory]::CreateDirectory([System.IO.Path]::Combine($script:AppControlManagerDirectory, 'MSIXBundleOutput')).FullName

              [System.IO.File]::Copy($FinalMSIXX64Path, [System.IO.Path]::Combine($MSIXBundleOutput, $FinalMSIXX64Name.Replace('.msix', '.appx')), $true)

              # The path to the final MSIX Bundle file
              [System.String]$MSIXBundle = [System.IO.Path]::Combine($MSIXBundleOutput, $FinalBundleFileName)

              function Get-MakeAppxPath {
                  [System.String]$BasePath = 'C:\Program Files (x86)\Windows Kits\10\bin'

                  # Get all subdirectories under the base path
                  [System.String[]]$VersionDirs = [System.IO.Directory]::GetDirectories($BasePath)

                  # Initialize the highest version with a minimal version value.
                  [System.Version]$HighestVersion = [System.Version]::New('0.0.0.0')
                  [System.String]$HighestVersionFolder = $null

                  # Loop through each directory to find the highest version folder.
                  foreach ($Dir in $VersionDirs) {
                      # Extract the folder name
                      [System.String]$FolderName = [System.IO.Path]::GetFileName($Dir)
                      [System.Version]$CurrentVersion = $null
                      # Try parsing the folder name as a Version.
                      if ([System.Version]::TryParse($FolderName, [ref] $CurrentVersion)) {
                          # Compare versions
                          if ($CurrentVersion.CompareTo($HighestVersion) -gt 0) {
                              $HighestVersion = $CurrentVersion
                              $HighestVersionFolder = $FolderName
                          }
                      }
                  }

                  # If no valid version folder is found
                  if (!$HighestVersionFolder) {
                      throw [System.IO.DirectoryNotFoundException]::New("No valid version directories found in $BasePath")
                  }

                  [string]$CPUArch = @{AMD64 = 'x64'; ARM64 = 'arm64' }[$Env:PROCESSOR_ARCHITECTURE]
                  if ([System.String]::IsNullOrWhiteSpace($CPUArch)) { throw [System.PlatformNotSupportedException]::New('Only AMD64 and ARM64 architectures are supported.') }

                  # Combine the base path, the highest version folder, the architecture folder, and the file name.
                  [System.String]$MakeAppxPath = [System.IO.Path]::Combine($BasePath, $HighestVersionFolder, $CPUArch, 'makeappx.exe')

                  return $MakeAppxPath
              }

              [System.String]$MakeAppxPath = Get-MakeAppxPath

              if ([System.string]::IsNullOrWhiteSpace($MakeAppxPath)) {
                  throw [System.IO.FileNotFoundException]::New('Could not find the makeappx.exe')
              }

              # https://learn.microsoft.com/windows/win32/appxpkg/make-appx-package--makeappx-exe-#to-create-a-package-bundle-using-a-directory-structure
              . $MakeAppxPath bundle /d $MSIXBundleOutput /p $MSIXBundle /o /v

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("MakeAppx failed creating the MSIXBundle. Exit Code: $LASTEXITCODE") }

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("MakeAppx failed creating the MSIXBundle. Exit Code: $LASTEXITCODE") }

              # Export the public certificate for users to install
              $CertExportPath = [System.IO.Path]::Combine($MSIXBundleOutput, 'OFFSECHQ_CodeSigning.cer')
              Export-Certificate -Cert $Cert -FilePath $CertExportPath -Type CERT
              Write-Host -Object "Certificate exported to: $CertExportPath" -ForegroundColor Green

              # Sign the MSIX Bundle with the self-signed certificate
              & $SignToolPath sign /fd $PackageHashAlgo @SignCredentialArgs /td $PackageHashAlgo /tr "http://timestamp.digicert.com" $MSIXBundle

              if ($LASTEXITCODE -ne 0) { throw [System.InvalidOperationException]::New("SignTool failed signing the MSIXBundle. Exit Code: $LASTEXITCODE") }

              Write-Host -Object "Successfully signed: $MSIXBundle" -ForegroundColor Green

              #Endregion

              #Endregion

              Write-Host -Object "X64 MSIX File Path: $FinalMSIXX64Path" -ForegroundColor Green
              Write-Host -Object "X64 MSIX File Name: $FinalMSIXX64Name" -ForegroundColor Green
              Write-Host -Object "X64 Symbols: $FinalMSIXX64SymbolPath" -ForegroundColor Green

              Write-Host -Object "MSIX Bundle File Path: $MSIXBundle" -ForegroundColor Yellow
              Write-Host -Object "MSIX Bundle File Name: $FinalBundleFileName" -ForegroundColor Yellow

              if ($Workflow) {

                  [XML]$CSProjXMLContent = Get-Content -Path $CsProjFilePath -Force
                  [string]$MSIXVersion = $CSProjXMLContent.Project.PropertyGroup.Version
                  [string]$MSIXVersion = $MSIXVersion.Trim() # It would have trailing whitespaces
                  if ([string]::IsNullOrWhiteSpace($FinalMSIXX64Path) -or [string]::IsNullOrWhiteSpace($FinalMSIXX64Name) -or [string]::IsNullOrWhiteSpace($MSIXVersion)) { throw 'Necessary info could not be found' }

                  # Write the MSIXVersion to GITHUB_ENV to set it as an environment variable for the entire workflow
                  Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "PACKAGE_VERSION=$MSIXVersion"

                  # Saving the details for the MSIX Bundle file
                  Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "MSIXBundle_PATH=$MSIXBundle"
                  Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "MSIXBundle_NAME=$FinalBundleFileName"

                  # Saving the details of the log files
                  Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "X64MSBuildLog_PATH=$((Resolve-Path -Path .\X64MSBuildLog.binlog).Path)"

                  # Saving the details of the X64 symbol file
                  Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "X64Symbol_PATH=$FinalMSIXX64SymbolPath"
                  Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "X64Symbol_NAME=$FinalMSIXX64SymbolName"

                  # https://github.com/microsoft/sbom-tool
                # Generating SBOM - only download if not cached
                if (-not (Test-Path "${Env:RUNNER_TEMP}\sbom-tool.exe")) {
                    Invoke-WebRequest -Uri 'https://github.com/microsoft/sbom-tool/releases/latest/download/sbom-tool-win-x64.exe' -OutFile "${Env:RUNNER_TEMP}\sbom-tool.exe"
                }

                  # https://github.com/microsoft/sbom-tool/blob/main/docs/sbom-tool-arguments.md
                  . "${Env:RUNNER_TEMP}\sbom-tool.exe" generate -b $MSIXBundleOutput -bc .\ -pn 'App Control Studio' -ps 'OFFSECHQ' -pv $MSIXVersion -nsb 'https://github.com/OFFSECHQ/windows-security-studio' -V Verbose -gt true -li true -pm true -D true -lto 80

                  # Saving the details of the SBOM file
                  Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "SBOM_PATH=$MSIXBundleOutput/_manifest/spdx_2.2/manifest.spdx.json"
                  Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value 'SBOM_NAME=manifest.spdx.json'

                  # Saving the details of the code signing certificate
                  Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "CERT_PATH=$CertExportPath"
                  Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "CERT_NAME=OFFSECHQ_CodeSigning.cer"
              }

              if ($Install -and $PackageFamilyName -eq 'OFFSECHQ.AppControlStudio_52ydnp6c4w3g1') {
                  (Invoke-RestMethod -Uri 'https://raw.githubusercontent.com/OFFSECHQ/windows-security-studio/main/Harden-Windows-Security.ps1') + "AppControl -Verbose -MSIXBundlePath '$MSIXBundle'" | Invoke-Expression
              }

              if ($Upload) {
                  dotnet clean '.\eXclude\PartnerCenter\PartnerCenter.slnx' --configuration Release
                  dotnet build '.\eXclude\PartnerCenter\PartnerCenter.slnx' --configuration Release --verbosity minimal
                  dotnet msbuild '.\eXclude\PartnerCenter\PartnerCenter.slnx' /p:Configuration=Release /p:Platform=x64 /p:PublishProfile=win-x64 /t:Publish -v:minimal

                  [System.String]$TokenEndpoint = $env:PARTNERCENTER_TOKENENDPOINT
                  [System.String]$ClientId = $env:PARTNERCENTER_CLIENTID
                  [System.String]$ClientSecret = $env:PARTNERCENTER_CLIENTSECRET
                  [System.String]$ApplicationId = $env:PARTNERCENTER_APPLICATIONID

                  [System.String]$PackageFilePath = $MSIXBundle
                  [System.String]$ReleaseNotesFilePath = (Resolve-Path -Path ReleaseNotes.txt).Path

                  . '.\eXclude\PartnerCenter\X64Output\PartnerCenter.exe' $TokenEndpoint $ClientId $ClientSecret $ApplicationId $PackageFilePath $ReleaseNotesFilePath
              }

              if ($null -ne $Stopwatch) {

                  $Stopwatch.Stop()

                  $Elapsed = $Stopwatch.Elapsed
                  [string]$Result = @"
          Execution Time:
          ----------------------------
          Total Time   : $($Elapsed.ToString('g'))
          Hours        : $($Elapsed.Hours)
          Minutes      : $($Elapsed.Minutes)
          Seconds      : $($Elapsed.Seconds)
          Milliseconds : $($Elapsed.Milliseconds)
          ----------------------------
          "@

                  Write-Host -Object $Result -ForegroundColor Cyan
              }
          }

          # GitHub Actions workflow invocation
          Build_ACM -DownloadRepo $false -InstallDeps $true -Workflow $true -UpdateWorkLoads $false -Install $false -Upload $false
          # Example of building the app from the source code and installing it on a clean system with self-signed certificate
          # Build_ACM -DownloadRepo $true -InstallDeps $true -Workflow $false -UpdateWorkLoads $false -Install $true -Upload $false
          # Example of building the app from the source code on a clean system and uploading it to the Partner Center
          # Build_ACM -DownloadRepo $true -InstallDeps $true -Workflow $false -UpdateWorkLoads $false -Install $false -Upload $true
          # Local Test
          # Build_ACM -DownloadRepo $false -InstallDeps $false -Workflow $false -UpdateWorkLoads $false -Install $false -Upload $false

      - name: Finding or Creating Draft Release
        id: find_draft_release
        shell: pwsh
        run: |
          $Headers = @{ Authorization = "token ${{ secrets.GITHUB_TOKEN }}"; Accept = "application/vnd.github.v3+json" }
          $RepoUrl = "https://api.github.com/repos/${{ github.repository }}"

          # Find the latest draft release via GitHub REST API
          $Response = Invoke-RestMethod -Uri "$RepoUrl/releases" -Headers $Headers
          # Find draft release for App Control Studio specifically (tag starts with acs-v)
          $DraftRelease = $Response | Where-Object -FilterScript { $_.draft -eq $true -and $_.tag_name -like 'acs-v*' } | Select-Object -First 1

          if (!$DraftRelease) {
              Write-Host -Object "No draft release found for App Control Studio. Creating a new one..." -ForegroundColor Yellow
              
              # Use package version from the build with acs- prefix
              $TagName = "acs-v${{ env.PACKAGE_VERSION }}"
              $ReleaseName = "App Control Studio v${{ env.PACKAGE_VERSION }}"
              
              # Create a new draft release
              $Body = @{
                  tag_name = $TagName
                  name = $ReleaseName
                  body = "App Control Studio $TagName - Auto-generated by workflow"
                  draft = $true
                  prerelease = $false
              } | ConvertTo-Json
              
              $DraftRelease = Invoke-RestMethod -Uri "$RepoUrl/releases" -Method Post -Headers $Headers -Body $Body -ContentType "application/json"
              Write-Host -Object "Created new draft release: $ReleaseName" -ForegroundColor Green
          }

          # Capture the draft release ID and tag
          $DRAFT_RELEASE_ID = $DraftRelease.id
          $DRAFT_RELEASE_TAG = $DraftRelease.tag_name

          # Save both the release ID and tag to environment variables for later steps
          Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "DRAFT_RELEASE_ID=$DRAFT_RELEASE_ID"
          Add-Content -Path ($env:GITHUB_ENV, $env:GITHUB_OUTPUT) -Value "DRAFT_RELEASE_TAG=$DRAFT_RELEASE_TAG"

          Write-Host -Object "GitHub Draft ID: $DRAFT_RELEASE_ID"
          Write-Host -Object "GitHub Draft Tag: $DRAFT_RELEASE_TAG"

      - name: Uploading Assets to the Draft Release
        shell: pwsh
        run: |
          # Create Release Zip
          $InstallKitDir = Join-Path $env:RUNNER_TEMP "App_Control_Studio_Install_Kit"
          New-Item -Path $InstallKitDir -ItemType Directory -Force

          Copy-Item -Path "${{ env.MSIXBundle_PATH }}" -Destination $InstallKitDir
          Copy-Item -Path "${{ env.CERT_PATH }}" -Destination $InstallKitDir
          Copy-Item -Path "Install.cmd" -Destination $InstallKitDir

          $ZipName = "App.Control.Studio_Install_Kit_v${{ env.PACKAGE_VERSION }}.zip"
          $ZipPath = Join-Path $env:RUNNER_TEMP $ZipName
          Compress-Archive -Path "$InstallKitDir\*" -DestinationPath $ZipPath

          # Standalone MSIXBundle for in-app updates (name format: App.Control.Studio_X.X.X.X.msixbundle)
          $StandaloneBundleName = "App.Control.Studio_${{ env.PACKAGE_VERSION }}.msixbundle"

          $Assets = @(
              @{ Path = $ZipPath; Name = $ZipName }
              @{ Path = "${{ env.MSIXBundle_PATH }}"; Name = $StandaloneBundleName }
              @{ Path = "${{ env.CERT_PATH }}"; Name = 'OFFSECHQ_CodeSigning.cer' }
              @{ Path = "${{ env.X64MSBuildLog_PATH }}"; Name = 'X64MSBuildLog.binlog' }
              @{ Path = "${{ env.X64Symbol_PATH }}"; Name = "${{ env.X64Symbol_NAME }}" }
              @{ Path = "${{ env.SBOM_PATH }}"; Name = "${{ env.SBOM_NAME }}" }
          )
          [string]$DraftReleaseId = $env:DRAFT_RELEASE_ID
          [string]$Repo = "${{ github.repository }}"
          [string]$AuthHeader = "token ${{ secrets.GITHUB_TOKEN }}"
          foreach ($Asset in $Assets) {
              if (-Not [string]::IsNullOrEmpty($Asset.Path)) {
                  [string]$UploadUrl = "https://uploads.github.com/repos/$Repo/releases/$DraftReleaseId/assets?name=$($Asset.Name)"
                  Write-Host -Object "Uploading $($Asset.Name) to draft release..."
                  $null = Invoke-RestMethod -Uri $UploadUrl -Method Put -InFile $Asset.Path -Headers @{
                      'Authorization' = $AuthHeader
                      'Content-Type'  = 'application/octet-stream'
                  }
              }
          }

      - name: Uploading Artifact 1
        uses: actions/upload-artifact@v7
        with:
          retention-days: 1
          compression-level: 0
          name: ${{ env.MSIXBundle_NAME }}
          path: ${{ env.MSIXBundle_PATH }}

      - name: Uploading Artifact 2
        uses: actions/upload-artifact@v7
        with:
          retention-days: 1
          compression-level: 0
          name: X64MSBuildLog.binlog
          path: ${{ env.X64MSBuildLog_PATH }}

      - name: Uploading Artifact 3
        uses: actions/upload-artifact@v7
        with:
          retention-days: 1
          compression-level: 0
          name: ${{ env.X64Symbol_NAME }}
          path: ${{ env.X64Symbol_PATH }}

      - name: Uploading Artifact 4
        uses: actions/upload-artifact@v7
        with:
          retention-days: 1
          compression-level: 0
          name: ${{ env.SBOM_NAME }}
          path: ${{ env.SBOM_PATH }}

      - name: Uploading Artifact 5
        uses: actions/upload-artifact@v7
        with:
          retention-days: 1
          compression-level: 0
          name: ${{ env.CERT_NAME }}
          path: ${{ env.CERT_PATH }}

  # The Attestation runs right after build and no other job, especially 3rd party actions/steps etc. should run in between.
  attest:
    needs: [build]
    runs-on: windows-2025
    permissions:
      attestations: write
      id-token: write

    steps:
      - name: Downloading all Artifacts
        uses: actions/download-artifact@v8
        with:
          path: Downloaded-Artifacts # Download all artifacts in this folder
          merge-multiple: true

      - name: Display structure of downloaded files
        run: ls -R Downloaded-Artifacts

      - name: Generating Artifact Attestation
        uses: actions/attest-build-provenance@v4
        with:
          # subject-path: "${{ needs.build.outputs.MSIXBundle_PATH }}, ${{ needs.build.outputs.X64MSBuildLog_PATH }}, ${{ needs.build.outputs.ARM64MSBuildLog_PATH }}, ${{ needs.build.outputs.X64Symbol_PATH }}, ${{ needs.build.outputs.ARM64Symbol_PATH }}"
          subject-path: "Downloaded-Artifacts/*" # Use all the files in the artifact downloads folder

  SbomAttest:
    needs: [build]
    runs-on: windows-2025
    permissions:
      contents: read
      attestations: write
      id-token: write

    steps:
      - name: Downloading all Artifacts
        uses: actions/download-artifact@v8
        with:
          path: Downloaded-Artifacts # Download all artifacts in this folder
          merge-multiple: true

      - name: Display structure of downloaded files
        run: ls -R Downloaded-Artifacts

      - name: Generating SBOM attestation
        uses: actions/attest-sbom@v4
        with:
          # subject-path: "${{ needs.build.outputs.MSIXBundle_PATH }}, ${{ needs.build.outputs.X64MSBuildLog_PATH }}, ${{ needs.build.outputs.ARM64MSBuildLog_PATH }}, ${{ needs.build.outputs.X64Symbol_PATH }}, ${{ needs.build.outputs.ARM64Symbol_PATH }}"
          subject-path: "Downloaded-Artifacts/*" # Use all the files in the artifact downloads folder
          sbom-path: ./Downloaded-Artifacts/manifest.spdx.json
          show-summary: true

  final:
    needs: [build, attest, SbomAttest]
    runs-on: windows-2025
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Check out the repository code
        uses: actions/checkout@v6

      - name: Updating The MSIXBundle Download Links and Version via Pull Request
        shell: pwsh
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          [string]$MSIXBundleName = "${{ needs.build.outputs.MSIXBundle_NAME }}"

          # Spaces in files added to the GitHub assets will be replaced with dots, so we need to do the same when constructing the download link
          [string]$AdjustedMSIXBundleName = $MSIXBundleName.Replace('App Control Studio', 'App.Control.Studio')

          [string]$DRAFT_RELEASE_TAG = "${{ needs.build.outputs.DRAFT_RELEASE_TAG }}"
          [string]$GitHubRepository = "${{ github.repository }}"
          [string]$PACKAGE_VERSION = "${{ needs.build.outputs.PACKAGE_VERSION }}"

          # Construct the download URL using the draft release tag and MSIXBundle file name
          [string]$DownloadURLForMSIXBundle = "https://github.com/$GitHubRepository/releases/download/$DRAFT_RELEASE_TAG/$AdjustedMSIXBundleName"

          # Path to the files that will be updated
          [string]$DownloadURLFilePathForMSIXBundle = '.\App Control Studio\MSIXBundleDownloadURL.txt'
          [string]$VersionFilePath = '.\App Control Studio\version.txt'

          Set-Content -Path $DownloadURLFilePathForMSIXBundle -Value $DownloadURLForMSIXBundle -Force
          Write-Host -Object "Updated MSIXBundleDownloadURL.txt with download URL: $DownloadURLForMSIXBundle"

          Set-Content -Path $VersionFilePath -Value $PACKAGE_VERSION -Force
          Write-Host -Object "Updated version.txt with version: $PACKAGE_VERSION"

          # Configure Git for committing changes
          git config --global user.email '101721830+OFFSECHQ@users.noreply.github.com'
          git config --global user.name 'offsechq'

          # Check if there are any changes to commit
          $GitStatus = git status --porcelain
          if ([string]::IsNullOrWhiteSpace($GitStatus)) {
              Write-Host -Object "No changes detected. Version and download URL files already up to date. Skipping PR creation." -ForegroundColor Yellow
              exit 0
          }

          # Create a new branch for the pull request, making sure branch name has valid characters
          [string]$NewBranchName = 'App-Control-Studio-DownloadLink-Version-Update'
          git checkout -b $NewBranchName

          [string]$CommitMessageAndPRTitle = "App-Control-Studio-DownloadLink-Version-Update-Version-$PACKAGE_VERSION"

          # Stage and commit the change
          git add $DownloadURLFilePathForMSIXBundle
          git add $VersionFilePath
          git commit -m $CommitMessageAndPRTitle

          # Push the new branch to the remote repository
          git push -u origin $NewBranchName --force

          [string]$PRBody = @"
          This PR updates MSIXBundleDownloadURL.txt to
          ``````
          $DownloadURLForMSIXBundle
          ``````
          And version.txt to
          ``````
          $PACKAGE_VERSION
          ``````

          "@

          # Create the pull request
          gh pr create --title $CommitMessageAndPRTitle --body $PRBody --base main --label 'Automated ' --assignee OFFSECHQ

          # Enable auto-merge so the PR merges automatically once checks pass
          gh pr merge --auto --squash --delete-branch
